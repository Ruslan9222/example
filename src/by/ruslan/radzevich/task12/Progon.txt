
1. Что будет выведено на экран?


int b = (int) Stream.of(1,3,6,7)
.filter(a-> a > 5)
.peek(a-> System.out.println(a))
.toList().stream()
.peek(a-> System.out.println(a))
.count();
System.out.println(b);


----------------------------------------------------------------------------------------

2. Что будет выведено на экран?


String s = "hello";
String s2 = s.replace("l", "L");
System.out.println(s2);


----------------------------------------------------------------------------------------

3. Что будет выведено на экран?


public static void main(String[] args) {
    final Object a = new Object();
    final Object b = new Object();

    Thread t1 = new Thread(() -> {
        synchronized (a) {
            sleep(100);
            synchronized (b) {
                System.out.println("T1 done");
            }
        }
    });

    Thread t2 = new Thread(() -> {
        synchronized (b) {
            sleep(100);
            synchronized (a) {
                System.out.println("T2 done");
            }
        }
    });

    t1.start();
    t2.start();
}


----------------------------------------------------------------------------------------


4. Необходимо придумать алгоритм, который сможет найти 2 числа в переданном массиве, которые дают в сумме targetSum.

int[] array = {1,2,4,5,6};

int targetSum = 6;
public void sumTarget(int[] array, int targetSum){

Map <Integer, Integer> map = new HashMap<>();
  for(int i=0; i<array.length; i++){
    int complete = targetSum - array[i];
     if(map.containsKey(complete)){
      return new int[]{map.get(complete) , i};
      }
      map.put(array[i], i);
}
      return null;
  }


public int[] twoSumBruteForce(int[] array, int targetSum) {
    for (int i = 0; i < array.length; i++) {
        for (int j = i + 1; j < array.length; j++) {
            if (array[i] + array[j] == targetSum) {
                return new int[]{i, j}; // возвращаем индексы
            }
        }
    }
    return null; // если пара не найдена
}

"Найдена нужная пара эелментов 2 + 4"




----------------------------------------------------------------------------------------


5. Необходимо написать метод который определяет палиндром строка или нет (двумя способами). "a bcс Ba" = true

public static boolean isPalindromeSimple(String s) {
String ignoreCase = s.replaceAll([^a-zZ-A0-9], "").toUpperCase();
String check = new StringBuilder(ignoreCase).reversed.toString;
return ignoreCase.equals(check);
}
public static boolean isPalindromeSimple(String s){
int left = 0;
int right = s.length()-1;

while(left<right){
while(left<right && !Character.isLetterOrDigit(s.charAt(left))){
left++;
}
while(left<right && !Character.isLetterOrDigit(s.charAt(right))){
right--;
}
if(Character.toLowerCase(s.charAt(left))!= Character.toLowerCase(s.charAt(right))){
return false;
}
left++;
right--;
}return true;
}


----------------------------------------------------------------------------------------


6. Найти все "пиковые" элементы, где элемент больше соседних. Например, для числа 7 в списке, оба соседа (3 и 1) меньше.

Дан список чисел:
List<Integer> numbers = Arrays.asList(1, 3, 7, 1, 2, 6, 3, 4, 5, 2);
List <Integer> peek = IntStream().range(1 , numbers.size()-1)
  .filter(el->numbers.get(el)<numbers.get(el-1)&&numbers.get(el)>numbers.get(el+1))
  .mapToObj(numbers::get)
  .toList



----------------------------------------------------------------------------------------


7. Отсортировать сотрудников сначала по возрасту, затем по зарплате (в порядке убывания).


Дан список сотрудников:

class Employee {
    String name;
    int age;
    double salary;

    // Конструктор, геттеры и сеттеры
}

List<Employee> employees = Arrays.asList(
    new Employee("Alice", 30, 50000),
    new Employee("Bob", 25, 60000),
    new Employee("Charlie", 35, 55000),
    new Employee("Diana", 30, 70000)
);

employees.stream()
 .sort(Employee::age , )



----------------------------------------------------------------------------------------

8. Реализовать упрощённый шедулер задач

Нужно написать класс MyScheduler, который позволяет планировать выполнение задач (Runnable) через заданное количество миллисекунд.
Шедулер должен поддерживать:

*Метод schedule(Runnable task, long delayMillis) — запуск задачи через delayMillis миллисекунд.

*Возможность запускать несколько задач параллельно.

*Корректное завершение работы (shutdown()), при котором новые задачи не принимаются, а старые завершаются.

Ограничения:

*Нельзя использовать ScheduledExecutorService или Timer.

*Можно использовать Thread и ExecutorService.

*Код должен быть потокобезопасным.



public class MyScheduler {

    public void schedule(Runnable task, long delayMillis) {
        // TODO: реализовать запуск task через delayMillis миллисекунд
    }

    public void shutdown() {
        // TODO: корректно завершить работу
    }

    public static void main(String[] args) {
        MyScheduler scheduler = new MyScheduler();

        scheduler.schedule(() -> System.out.println("Task 1 executed at " + System.currentTimeMillis()), 1000);
        scheduler.schedule(() -> System.out.println("Task 2 executed at " + System.currentTimeMillis()), 2000);

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        scheduler.shutdown();
    }
}




























